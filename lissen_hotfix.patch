diff -ruN lissen_zip/lib/features/sessions/ui/session_screen.dart lissen_fix/lib/features/sessions/ui/session_screen.dart
--- lissen_zip/lib/features/sessions/ui/session_screen.dart	2025-12-28 19:45:36.000000000 +0000
+++ lissen_fix/lib/features/sessions/ui/session_screen.dart	2025-12-29 03:59:10.117976261 +0000
@@ -1,939 +1,931 @@
-import 'dart:async'; // necesario para Stream.periodic
-
-import 'package:flutter/material.dart';
-import 'package:flutter/services.dart'; // üëà para HapticFeedback
-import 'package:cloud_firestore/cloud_firestore.dart';
-import 'package:firebase_auth/firebase_auth.dart';
-import 'package:zego_uikit_prebuilt_call/zego_uikit_prebuilt_call.dart';
-import 'package:zego_zim/zego_zim.dart';
-import 'package:zego_zimkit/zego_zimkit.dart';
-import '../../payments/payments_api.dart';
-import '../../zego/zego_config.dart';
-import '../../zego/zego_token_service.dart';
-
-class SessionConversationScreen extends StatefulWidget {
-  final String sessionId;
-
-  const SessionConversationScreen({super.key, required this.sessionId});
-
-  @override
-  State<SessionConversationScreen> createState() =>
-      _SessionConversationScreenState();
-}
-
-class _SessionConversationScreenState extends State<SessionConversationScreen> {
-  late final DocumentReference<Map<String, dynamic>> _sessionRef;
-  bool _finishing = false;
-  bool _captureOk = false;
-  final ZegoTokenService _zegoTokenService = ZegoTokenService();
-
-  bool _zegoConnecting = false;
-  bool _zegoReady = false;
-  String? _zegoError;
-  ZegoTokenResponse? _zegoToken;
-
-
-  // M√≠nimo a cobrar cuando la que corta es la compa√±era
-  static const int kMinBillingMinutes = 10;
-
-  // Mostrar u ocultar el aviso de reglas
-  bool _showBillingHint = true;
-
-  // ‚úÖ Mostrar u ocultar el aviso de l√≠mites (solo compa√±era)
-  bool _showSafetyHint = true;
-
-  // Para no disparar el timeout m√°s de una vez
-  bool _autoTimeoutTriggered = false;
-
-  // üîπ Estado local de la sesi√≥n
-  Map<String, dynamic>? _sessionData;
-  bool _sessionLoading = true;
-  String? _sessionError;
-
-  // üîπ Listener en tiempo real de la sesi√≥n
-  StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>? _sessionSub;
-
-  @override
-  void initState() {
-    super.initState();
-    _sessionRef =
-        FirebaseFirestore.instance.collection('sessions').doc(widget.sessionId);
-
-    // Escuchar la sesi√≥n en tiempo real para actualizar la UI
-    _sessionLoading = true;
-    _sessionSub = _sessionRef.snapshots().listen(
-      (snap) {
-        if (!mounted) return;
-        if (!snap.exists) {
-          setState(() {
-            _sessionData = null;
-            _sessionError = 'La sesi√≥n no existe o fue eliminada.';
-            _sessionLoading = false;
-          });
-          return;
-        }
-        setState(() {
-          _sessionData = snap.data();
-          _sessionLoading = false;
-          _sessionError = null;
-        });
-        _ensureZegoReady();
-      },
-      onError: (e) {
-        if (!mounted) return;
-        setState(() {
-          _sessionError = 'Error en la sesi√≥n: $e';
-          _sessionLoading = false;
-        });
-      },
-    );
-  }
-
-  @override
-  void dispose() {
-    _sessionSub?.cancel();
-    super.dispose();
-  }
-
-  // ============================================================
-  // üîß Utilidades internas
-  // ============================================================
-
-  Future<void> _loadSessionOnce() async {
-    setState(() {
-      _sessionLoading = true;
-      _sessionError = null;
-    });
-    try {
-      final snap = await _sessionRef.get();
-      if (!snap.exists) {
-        setState(() {
-          _sessionData = null;
-          _sessionError = 'La sesi√≥n no existe o fue eliminada.';
-          _sessionLoading = false;
-        });
-        return;
-      }
-      setState(() {
-        _sessionData = snap.data();
-        _sessionLoading = false;
-      });
-      _ensureZegoReady();
-    } catch (e) {
-      setState(() {
-        _sessionError = 'Error cargando sesi√≥n: $e';
-        _sessionLoading = false;
-      });
-    }
-  }
-
-  String _resolveMyAlias(Map<String, dynamic> data, String myUid) {
-    final speakerId = (data['speakerId'] ?? '').toString();
-    if (speakerId == myUid) {
-      return (data['speakerAlias'] ?? 'Hablante').toString();
-    }
-    return (data['companionAlias'] ?? 'Compa√±era').toString();
-  }
-
-  String _resolveOtherUserId(Map<String, dynamic> data, String myUid) {
-    final speakerId = (data['speakerId'] ?? '').toString();
-    final companionId = (data['companionId'] ?? '').toString();
-    return speakerId == myUid ? companionId : speakerId;
-  }
-
-  Future<void> _ensureZegoGroup({
-    required String groupId,
-    required String groupName,
-    required List<String> userIds,
-  }) async {
-    try {
-      await (ZIMKit() as dynamic).createGroup(
-        groupName: groupName,
-        groupID: groupId,
-        userIDs: userIds,
-      );
-    } catch (_) {
-      try {
-        await (ZIMKit() as dynamic).createGroup(
-          groupName,
-          groupId,
-          userIDs: userIds,
-        );
-      } catch (_) {}
-      try {
-        await ZIMKit().joinGroup(groupId);
-      } catch (_) {}
-    }
-  }
-
-  Future<void> _ensureZegoReady() async {
-    if (_zegoReady || _zegoConnecting || _sessionData == null) return;
-    final user = FirebaseAuth.instance.currentUser;
-    if (user == null) return;
-
-    setState(() {
-      _zegoConnecting = true;
-      _zegoError = null;
-    });
-
-    try {
-      final data = _sessionData!;
-      final myAlias = _resolveMyAlias(data, user.uid);
-      final otherUserId = _resolveOtherUserId(data, user.uid);
-      final token = await _zegoTokenService.fetchToken(
-        userId: user.uid,
-        userName: myAlias,
-      );
-
-      final loginCode =
-          await ZIMKit().connectUser(id: user.uid, name: myAlias);
+import 'dart:async'; // necesario para Stream.periodic
+
+import 'package:flutter/material.dart';
+import 'package:flutter/services.dart'; // üëà para HapticFeedback
+import 'package:cloud_firestore/cloud_firestore.dart';
+import 'package:firebase_auth/firebase_auth.dart';
+import 'package:zego_uikit_prebuilt_call/zego_uikit_prebuilt_call.dart';
+import 'package:zego_uikit_signaling_plugin/zego_uikit_signaling_plugin.dart';
+import 'package:zego_zim/zego_zim.dart';
+import 'package:zego_zimkit/zego_zimkit.dart';
+import '../../payments/payments_api.dart';
+import '../../zego/zego_config.dart';
+
+class SessionConversationScreen extends StatefulWidget {
+  final String sessionId;
+
+  const SessionConversationScreen({super.key, required this.sessionId});
+
+  @override
+  State<SessionConversationScreen> createState() =>
+      _SessionConversationScreenState();
+}
+
+class _SessionConversationScreenState extends State<SessionConversationScreen> {
+  late final DocumentReference<Map<String, dynamic>> _sessionRef;
+  bool _finishing = false;
+  bool _captureOk = false;
+
+  // ‚úÖ Para llamadas tipo WhatsApp (invitar/recibir)
+  bool _callInvitationInited = false;
+
+  bool _zegoConnecting = false;
+  bool _zegoReady = false;
+  String? _zegoError;
+
+
+  // M√≠nimo a cobrar cuando la que corta es la compa√±era
+  static const int kMinBillingMinutes = 10;
+
+  // Mostrar u ocultar el aviso de reglas
+  bool _showBillingHint = true;
+
+  // ‚úÖ Mostrar u ocultar el aviso de l√≠mites (solo compa√±era)
+  bool _showSafetyHint = true;
+
+  // Para no disparar el timeout m√°s de una vez
+  bool _autoTimeoutTriggered = false;
+
+  // üîπ Estado local de la sesi√≥n
+  Map<String, dynamic>? _sessionData;
+  bool _sessionLoading = true;
+  String? _sessionError;
+
+  // üîπ Listener en tiempo real de la sesi√≥n
+  StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>? _sessionSub;
+
+  @override
+  void initState() {
+    super.initState();
+    _sessionRef =
+        FirebaseFirestore.instance.collection('sessions').doc(widget.sessionId);
+
+    // Escuchar la sesi√≥n en tiempo real para actualizar la UI
+    _sessionLoading = true;
+    _sessionSub = _sessionRef.snapshots().listen(
+      (snap) {
+        if (!mounted) return;
+        if (!snap.exists) {
+          setState(() {
+            _sessionData = null;
+            _sessionError = 'La sesi√≥n no existe o fue eliminada.';
+            _sessionLoading = false;
+          });
+          return;
+        }
+        setState(() {
+          _sessionData = snap.data();
+          _sessionLoading = false;
+          _sessionError = null;
+        });
+        _ensureZegoReady();
+      },
+      onError: (e) {
+        if (!mounted) return;
+        setState(() {
+          _sessionError = 'Error en la sesi√≥n: $e';
+          _sessionLoading = false;
+        });
+      },
+    );
+  }
+
+  @override
+  void dispose() {
+    if (_callInvitationInited) {
+      ZegoUIKitPrebuiltCallInvitationService().uninit();
+      _callInvitationInited = false;
+    }
+    _sessionSub?.cancel();
+    super.dispose();
+  }
+
+  // ============================================================
+  // üîß Utilidades internas
+  // ============================================================
+
+  Future<void> _loadSessionOnce() async {
+    setState(() {
+      _sessionLoading = true;
+      _sessionError = null;
+    });
+    try {
+      final snap = await _sessionRef.get();
+      if (!snap.exists) {
+        setState(() {
+          _sessionData = null;
+          _sessionError = 'La sesi√≥n no existe o fue eliminada.';
+          _sessionLoading = false;
+        });
+        return;
+      }
+      setState(() {
+        _sessionData = snap.data();
+        _sessionLoading = false;
+      });
+      _ensureZegoReady();
+    } catch (e) {
+      setState(() {
+        _sessionError = 'Error cargando sesi√≥n: $e';
+        _sessionLoading = false;
+      });
+    }
+  }
+
+  String _resolveMyAlias(Map<String, dynamic> data, String myUid) {
+    final speakerId = (data['speakerId'] ?? '').toString();
+    if (speakerId == myUid) {
+      return (data['speakerAlias'] ?? 'Hablante').toString();
+    }
+    return (data['companionAlias'] ?? 'Compa√±era').toString();
+  }
+
+  String _resolveOtherUserId(Map<String, dynamic> data, String myUid) {
+    final speakerId = (data['speakerId'] ?? '').toString();
+    final companionId = (data['companionId'] ?? '').toString();
+    return speakerId == myUid ? companionId : speakerId;
+  }
+
+  Future<void> _ensureZegoGroup({
+    required String groupId,
+    required String groupName,
+    required List<String> userIds,
+  }) async {
+    try {
+      await (ZIMKit() as dynamic).createGroup(
+        groupName: groupName,
+        groupID: groupId,
+        userIDs: userIds,
+      );
+    } catch (_) {
+      try {
+        await (ZIMKit() as dynamic).createGroup(
+          groupName,
+          groupId,
+          userIDs: userIds,
+        );
+      } catch (_) {}
+      try {
+        await ZIMKit().joinGroup(groupId);
+      } catch (_) {}
+    }
+  }
+
+  Future<void> _ensureZegoReady() async {
+    if (_zegoReady || _zegoConnecting || _sessionData == null) return;
+    final user = FirebaseAuth.instance.currentUser;
+    if (user == null) return;
+
+    setState(() {
+      _zegoConnecting = true;
+      _zegoError = null;
+    });
+
+    try {
+      final data = _sessionData!;
+      final myAlias = _resolveMyAlias(data, user.uid);
+      final otherUserId = _resolveOtherUserId(data, user.uid);
+
+      // 1) Conectar usuario a ZIM (chat)
+      final loginCode = await ZIMKit().connectUser(id: user.uid, name: myAlias);
       if (loginCode != 0) {
         throw Exception('No se pudo iniciar sesion en ZIM: $loginCode');
       }
-
-      await _ensureZegoGroup(
-        groupId: widget.sessionId,
-        groupName: 'session-${widget.sessionId}',
-        userIds: [user.uid, otherUserId],
-      );
-
-      if (!mounted) return;
-      setState(() {
-        _zegoToken = token;
-        _zegoReady = true;
-      });
-    } catch (e) {
-      if (!mounted) return;
-      setState(() {
-        _zegoError = 'No se pudo conectar a Zego: $e';
-      });
-    } finally {
-      if (mounted) {
-        setState(() => _zegoConnecting = false);
-      }
-    }
-  }
-
-  void _openCall({required bool video}) {
-    final user = FirebaseAuth.instance.currentUser;
-    if (user == null) return;
-    if (!_zegoReady || _zegoToken == null) {
-      ScaffoldMessenger.of(context).showSnackBar(
-        const SnackBar(
-          content: Text('El chat a√∫n se est√° conectando.'),
-        ),
-      );
-      return;
-    }
-
-    final data = _sessionData;
-    if (data == null) return;
-    final myAlias = _resolveMyAlias(data, user.uid);
-    final config = video
-        ? ZegoUIKitPrebuiltCallConfig.oneOnOneVideoCall()
-        : ZegoUIKitPrebuiltCallConfig.oneOnOneVoiceCall();
-
-    Navigator.of(context).push(
-      MaterialPageRoute(
-        builder: (_) => ZegoUIKitPrebuiltCall(
-          appID: kZegoAppId,
-          userID: user.uid,
-          userName: myAlias,
-          callID: widget.sessionId,
-          token: _zegoToken!.token,
-          config: config,
-        ),
-      ),
-    );
-  }
-
-
-
-  // ============================================================
-  // üîµ FINALIZAR SESI√ìN (l√≥gica de cobros manual: bot√≥n)
-  // ============================================================
-  Future<void> _finishSession() async {
-    if (_finishing) return;
-
-    final user = FirebaseAuth.instance.currentUser;
-    if (user == null) return;
-
-    // Vibraci√≥n media al finalizar sesi√≥n
-    HapticFeedback.mediumImpact();
-
-    setState(() => _finishing = true);
-
-    try {
-      final snap = await _sessionRef.get();
-      final data = snap.data();
-      if (data == null) {
-        if (mounted) {
-          ScaffoldMessenger.of(context).showSnackBar(
-            const SnackBar(content: Text('La sesi√≥n ya no existe.')),
-          );
-        }
-        await _loadSessionOnce();
-        return;
-      }
-
-      final status = data['status'] as String? ?? 'active';
-      if (status != 'active') {
-        if (mounted) {
-          ScaffoldMessenger.of(context).showSnackBar(
-            const SnackBar(content: Text('La sesi√≥n ya estaba finalizada.')),
-          );
-        }
-        await _loadSessionOnce();
-        return;
-      }
-
-      final speakerId = data['speakerId'] as String? ?? '';
-      final endedBy = user.uid == speakerId ? 'speaker' : 'companion';
-
-      // Duraci√≥n total contratada (ej. 30 min)
-      final durationTotal = data['durationMinutes'] as int? ?? 30;
-
-      // Calcular minutos reales usados (desde createdAt hasta ahora)
-      int realMinutes = 0;
-      final createdAtTs = data['createdAt'] as Timestamp?;
-      if (createdAtTs != null) {
-        final createdAt = createdAtTs.toDate();
-        final now = DateTime.now();
-        final diffMinutes = now.difference(createdAt).inMinutes;
-        if (diffMinutes >= 0) {
-          realMinutes = diffMinutes;
-        }
-      }
-
-      // üîí Candado: nunca m√°s de lo reservado
-      if (realMinutes > durationTotal) {
-        realMinutes = durationTotal;
-      }
-
-      // Calcular minutos a cobrar seg√∫n qui√©n termin√≥
-      int billingMinutes;
-      bool minChargeApplied = false;
-
-      if (endedBy == 'speaker') {
-        // Si el hablante corta, paga TODO (duraci√≥n contratada)
-        billingMinutes = durationTotal;
-      } else {
-        // Si la compa√±era corta, m√≠nimo 10 min
-        if (realMinutes < kMinBillingMinutes) {
-          billingMinutes = kMinBillingMinutes;
-          minChargeApplied = true;
-        } else {
-          billingMinutes = realMinutes;
-        }
-      }
-
-      final updateData = <String, dynamic>{
-        'status': 'completed',
-        'endedBy': endedBy,
-        'completedAt': FieldValue.serverTimestamp(),
-        'updatedAt': FieldValue.serverTimestamp(),
-        'realDurationMinutes': realMinutes,
-        'billingMinutes': billingMinutes,
-        'billingMinLimit': kMinBillingMinutes,
-        'minChargeApplied': minChargeApplied,
-      };
-
-      await _sessionRef.update(updateData);
-
-      try {
-        await PaymentsApi().captureSessionPayment(sessionId: widget.sessionId);
-        _captureOk = true;
-      } catch (e) {
-        _captureOk = false;
-        debugPrint('Stripe capture fallo: $e');
-      }
-
-
-      // Mezclamos los datos antiguos con los nuevos para actualizar la UI
-      final mergedData = {...data, ...updateData};
-
-      if (mounted) {
-        // Actualizamos _sessionData para que la UI refleje el cambio
-        setState(() {
-          _sessionData = mergedData;
-        });
-
-        ScaffoldMessenger.of(context).showSnackBar(
-          SnackBar(
-            content: Text(
-              _captureOk
-                  ? 'Sesi√≥n finalizada ‚úÖ (cobro capturado)'
-                  : 'Sesi√≥n finalizada ‚úÖ (cobro pendiente ‚ö†Ô∏è)',
-            ),
-          ),
-        );
-
-      }
-    } catch (e) {
-      if (mounted) {
-        ScaffoldMessenger.of(context).showSnackBar(
-          SnackBar(content: Text('No se pudo finalizar la sesi√≥n: $e')),
-        );
-      }
-    }
- finally {
-      if (mounted) setState(() => _finishing = false);
-    }
-  }
-
-  // ============================================================
-  // üîµ AUTO-TIMEOUT (se llama solo desde el reloj cuando se cumple el tiempo)
-  // ============================================================
-  Future<void> _autoTimeoutSession() async {
-    if (_autoTimeoutTriggered) return; // seguridad extra
-    _autoTimeoutTriggered = true;
-
-    try {
-      final snap = await _sessionRef.get();
-      final data = snap.data();
-      if (data == null) return;
-
-      final status = data['status'] as String? ?? 'active';
-      if (status != 'active') return;
-
-      final durationTotal = data['durationMinutes'] as int? ?? 30;
-
-      // En timeout consideramos que se cumpli√≥ la duraci√≥n contratada
-      final realMinutes = durationTotal;
-      final billingMinutes = durationTotal;
-
-      final updateData = <String, dynamic>{
-        'status': 'completed',
-        'endedBy': 'timeout',
-        'completedAt': FieldValue.serverTimestamp(),
-        'updatedAt': FieldValue.serverTimestamp(),
-        'realDurationMinutes': realMinutes,
-        'billingMinutes': billingMinutes,
-        'billingMinLimit': kMinBillingMinutes,
-        'minChargeApplied': false,
-      };
-
-      await _sessionRef.update(updateData);
-
-      if (mounted) {
-        ScaffoldMessenger.of(context).showSnackBar(
-          const SnackBar(content: Text('La sesi√≥n termin√≥ autom√°ticamente.')),
-        );
-      }
-    } catch (_) {
-      // Si falla, simplemente no hacemos nada m√°s.
-    }
-  }
-
-  // ============================================================
-  // üîµ CONFIRMAR FINALIZAR SESI√ìN
-  // ============================================================
-  Future<void> _confirmFinishSession() async {
-    if (_finishing) return;
-
-    final shouldEnd =
-        await showDialog<bool>(
-          context: context,
-          builder: (context) {
-            return AlertDialog(
-              title: const Text('Finalizar sesi√≥n'),
-              content: const Text(
-                '¬øSeguro que quieres finalizar la sesi√≥n? '
-                'Esta acci√≥n no se puede deshacer.',
-              ),
-              actions: [
-                TextButton(
-                  onPressed: () => Navigator.of(context).pop(false),
-                  child: const Text('Cancelar'),
-                ),
-                ElevatedButton(
-                  onPressed: () => Navigator.of(context).pop(true),
-                  child: const Text('S√≠, finalizar'),
-                ),
-              ],
-            );
-          },
-        ) ??
-        false;
-
-    if (!shouldEnd) return;
-
-    await _finishSession();
-  }
-
-  // ============================================================
-  // üîµ UI COMPLETA DE LA SESI√ìN
-  // ============================================================
-  @override
-  Widget build(BuildContext context) {
-    final user = FirebaseAuth.instance.currentUser;
-    if (user == null) {
-      return const Scaffold(body: Center(child: Text('Debes iniciar sesi√≥n.')));
-    }
-
-    // ‚è≥ Carga inicial de la sesi√≥n
-    if (_sessionLoading) {
-      return Scaffold(
-        appBar: AppBar(title: const Text('Sesi√≥n')),
-        body: const Center(child: CircularProgressIndicator()),
-      );
-    }
-
-    if (_sessionError != null || _sessionData == null) {
-      return Scaffold(
-        appBar: AppBar(title: const Text('Sesi√≥n')),
-        body: Center(
-          child: Text(
-            _sessionError ?? 'La sesi√≥n no existe o fue eliminada.',
-            textAlign: TextAlign.center,
-          ),
-        ),
-      );
-    }
-
-    final data = _sessionData!;
-    final status = data['status'] as String? ?? 'active';
-    final endedBy = data['endedBy'] as String?;
-    final isActive = status == 'active';
-
-    final speakerAlias = data['speakerAlias'] ?? 'Hablante';
-    final companionAlias = data['companionAlias'] ?? 'Compa√±era';
-
-    final price = (data['priceCents'] ?? 0) / 100.0;
-    final duration = data['durationMinutes'] as int? ?? 30;
-    final currency = (data['currency'] ?? 'usd').toUpperCase();
-
-    final realDuration = data['realDurationMinutes'] as int?;
-    final billingMinutes = data['billingMinutes'] as int?;
-    final minChargeApplied = data['minChargeApplied'] as bool? ?? false;
-    final billingMinLimit =
-        data['billingMinLimit'] as int? ?? kMinBillingMinutes;
-
-    final isSpeakerInSession = data['speakerId'] == user.uid;
-    final otherAlias = isSpeakerInSession ? companionAlias : speakerAlias;
-
-    // createdAt para el reloj
-    final createdAtTs = data['createdAt'] as Timestamp?;
-    final createdAt = createdAtTs?.toDate();
-
-    // Label de estado amigable
-    String statusLabel;
-    if (status == 'active') {
-      statusLabel = 'Activa';
-    } else if (status == 'completed') {
-      if (endedBy == 'speaker') {
-        statusLabel = 'Finalizada por hablante';
-      } else if (endedBy == 'companion') {
-        statusLabel = 'Finalizada por compa√±era';
-      } else if (endedBy == 'timeout') {
-        statusLabel = 'Finalizada por tiempo';
-      } else {
-        statusLabel = 'Finalizada';
-      }
-    } else {
-      statusLabel = status;
-    }
-
-    // Texto de duraci√≥n compacto (cuando ya termin√≥)
-    String durationText;
-    if (!isActive && realDuration != null && billingMinutes != null) {
-      if (minChargeApplied) {
-        durationText =
-            'Res: $duration min ‚Ä¢ Real: $realDuration ‚Ä¢ Cobro: $billingMinutes (min $billingMinLimit)';
-      } else {
-        durationText =
-            'Res: $duration min ‚Ä¢ Real: $realDuration ‚Ä¢ Cobro: $billingMinutes';
-      }
-    } else if (realDuration != null && !isActive) {
-      durationText = 'Res: $duration min ‚Ä¢ Real: $realDuration';
-    } else {
-      durationText = 'Reservada: $duration min';
-    }
-
-    // ‚õî BLOQUEAR BACK mientras la sesi√≥n est√° activa
-    return WillPopScope(
-      onWillPop: () async {
-        if (isActive) {
-          ScaffoldMessenger.of(context).showSnackBar(
-            const SnackBar(
-              content: Text(
-                'No puedes salir de una sesi√≥n activa. '
-                'Primero debes finalizarla.',
-              ),
-            ),
-          );
-          return false;
-        }
-        return true;
-      },
-      child: Scaffold(
-        resizeToAvoidBottomInset: true,
-        appBar: AppBar(
-          title: Text(isActive ? otherAlias : 'Sesi√≥n finalizada'),
-          centerTitle: true,
-          actions: [
-            // Placeholder llamada de voz
-            IconButton(
-              icon: const Icon(Icons.call),
-              onPressed: isActive ? () => _openCall(video: false) : null,
-            ),
-            // Placeholder videollamada
-            IconButton(
-              icon: const Icon(Icons.videocam),
-              onPressed: isActive ? () => _openCall(video: true) : null,
-            ),
-            // Bot√≥n peque√±o para finalizar sesi√≥n (solo si est√° activa)
-            if (isActive)
-              IconButton(
-                icon: _finishing
-                    ? const SizedBox(
-                        height: 16,
-                        width: 16,
-                        child: CircularProgressIndicator(strokeWidth: 2),
-                      )
-                    : const Icon(Icons.call_end),
-                tooltip: 'Finalizar sesi√≥n',
-                onPressed: _finishing ? null : _confirmFinishSession,
-              ),
-          ],
-        ),
-        body: Column(
-          children: [
-            // ======================================================
-            // üî∏ HEADER PEQUE√ëO DE SESI√ìN
-            // ======================================================
-            Padding(
-              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
-              child: Row(
-                children: [
-                  CircleAvatar(
-                    radius: 18,
-                    child: Text(
-                      otherAlias.isNotEmpty ? otherAlias[0].toUpperCase() : '?',
-                    ),
-                  ),
-                  const SizedBox(width: 10),
-                  Expanded(
-                    child: Column(
-                      crossAxisAlignment: CrossAxisAlignment.start,
-                      children: [
-                        Text(
-                          'H: $speakerAlias ‚Ä¢ C: $companionAlias',
-                          style: const TextStyle(
-                            fontSize: 12,
-                            color: Colors.grey,
-                          ),
-                          overflow: TextOverflow.ellipsis,
-                        ),
-                        const SizedBox(height: 2),
-                        Text(
-                          durationText,
-                          style: const TextStyle(
-                            fontSize: 11,
-                            color: Colors.grey,
-                          ),
-                        ),
-                      ],
-                    ),
-                  ),
-                  const SizedBox(width: 8),
-                  Column(
-                    crossAxisAlignment: CrossAxisAlignment.end,
-                    children: [
-                      // ‚è±Ô∏è Reloj visual + auto-timeout
-                      if (isActive && createdAt != null)
-                        StreamBuilder<int>(
-                          stream: Stream.periodic(const Duration(seconds: 1), (
-                            _,
-                          ) {
-                            final diff = DateTime.now()
-                                .difference(createdAt)
-                                .inSeconds;
-                            return diff < 0 ? 0 : diff;
-                          }),
-                          builder: (context, snapshot) {
-                            final totalSeconds = snapshot.data ?? 0;
-                            final hours = totalSeconds ~/ 3600;
-                            final minutes = (totalSeconds % 3600) ~/ 60;
-                            final seconds = totalSeconds % 60;
-
-                            String formatted;
-                            if (hours > 0) {
-                              formatted =
-                                  '${hours.toString().padLeft(2, '0')}'
-                                  ':${minutes.toString().padLeft(2, '0')}'
-                                  ':${seconds.toString().padLeft(2, '0')}';
-                            } else {
-                              formatted =
-                                  '${minutes.toString().padLeft(2, '0')}'
-                                  ':${seconds.toString().padLeft(2, '0')}';
-                            }
-
-                            // üî• Auto-timeout: cuando se cumple la duraci√≥n
-                            final sessionTotalSeconds = duration * 60;
-                            if (isActive &&
-                                !_autoTimeoutTriggered &&
-                                sessionTotalSeconds > 0 &&
-                                totalSeconds >= sessionTotalSeconds) {
-                              _autoTimeoutSession();
-                            }
-
-                            return Text(
-                              'Tiempo: $formatted',
-                              style: const TextStyle(
-                                fontSize: 11,
-                                color: Colors.grey,
-                              ),
-                            );
-                          },
-                        ),
-                      const SizedBox(height: 2),
-                      Text(
-                        '\$${price.toStringAsFixed(2)} $currency',
-                        style: const TextStyle(
-                          fontSize: 12,
-                          fontWeight: FontWeight.w600,
-                        ),
-                      ),
-                      const SizedBox(height: 2),
-                      Text(
-                        statusLabel,
-                        style: TextStyle(
-                          fontSize: 11,
-                          color: isActive ? Colors.greenAccent : Colors.redAccent,
-                        ),
-                      ),
-                    ],
-                  ),
-                ],
-              ),
-            ),
-
-            // ======================================================
-            // üî∏ BARRA DE PROGRESO DE LA SESI√ìN (‚úÖ FIX COLOR / TRACK)
-            // ======================================================
-            if (isActive && createdAt != null)
-              Padding(
-                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
-                child: StreamBuilder<int>(
-                  stream: Stream.periodic(const Duration(seconds: 1), (_) {
-                    final diff = DateTime.now().difference(createdAt).inSeconds;
-                    return diff < 0 ? 0 : diff;
-                  }),
-                  builder: (context, snapshot) {
-                    final totalSeconds = snapshot.data ?? 0;
-                    final totalSessionSeconds = duration * 60;
-
-                    double progress = 0;
-                    if (totalSessionSeconds > 0) {
-                      progress = totalSeconds / totalSessionSeconds;
-                      if (progress.isNaN || progress.isInfinite) progress = 0;
-                      if (progress < 0) progress = 0;
-                      if (progress > 1) progress = 1;
-                    }
-
-                    final percent =
-                        (progress * 100).clamp(0, 100).toStringAsFixed(0);
-
-                    return Column(
-                      crossAxisAlignment: CrossAxisAlignment.stretch,
-                      children: [
-                        ClipRRect(
-                          borderRadius: BorderRadius.circular(8),
-                          child: LinearProgressIndicator(
-                            value: progress,
-                            minHeight: 6,
-                            // ‚úÖ en lugar del verde del theme
-                            color: const Color(0xFF4F46E5),
-                            // ‚úÖ track neutro (evita que se vea ‚Äúrelleno‚Äù desde inicio)
-                            backgroundColor: Colors.white12,
-                          ),
-                        ),
-                        const SizedBox(height: 4),
-                        Text(
-                          'Progreso de la sesi√≥n: $percent%',
-                          textAlign: TextAlign.right,
-                          style: const TextStyle(fontSize: 11, color: Colors.grey),
-                        ),
-                      ],
-                    );
-                  },
-                ),
-              ),
-
-            // ======================================================
-            // üî∏ AVISO L√çMITES (‚úÖ SOLO COMPA√ëERA, CERRABLE)
-            // ======================================================
-            if (isActive && !isSpeakerInSession && _showSafetyHint)
-              Padding(
-                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
-                child: Stack(
-                  children: [
-                    _buildSafetyHintForCompanion(),
-                    Positioned(
-                      right: 4,
-                      top: 4,
-                      child: InkWell(
-                        onTap: () => setState(() => _showSafetyHint = false),
-                        child: const Icon(Icons.close, size: 16),
-                      ),
-                    ),
-                  ],
-                ),
-              ),
-
-            // ======================================================
-            // üî∏ AVISO DE REGLA DE COBRO (con bot√≥n de cerrar)
-            // ======================================================
-            if (isActive && _showBillingHint)
-              Padding(
-                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
-                child: Stack(
-                  children: [
-                    _buildBillingHint(isSpeakerInSession),
-                    Positioned(
-                      right: 4,
-                      top: 4,
-                      child: InkWell(
-                        onTap: () {
-                          setState(() {
-                            _showBillingHint = false;
-                          });
-                        },
-                        child: const Icon(Icons.close, size: 16),
-                      ),
-                    ),
-                  ],
-                ),
-              ),
-
-            Expanded(child: _buildZegoChat(isActive: isActive)),
-          ],
-        ),
-      ),
-    );
-  }
-
-  Widget _buildZegoChat({required bool isActive}) {
-    if (_zegoError != null) {
-      return Center(
-        child: Text(
-          _zegoError!,
-          textAlign: TextAlign.center,
-          style: const TextStyle(color: Colors.redAccent),
-        ),
-      );
-    }
-
-    if (!_zegoReady) {
-      return const Center(child: CircularProgressIndicator());
-    }
-
-    Widget chatBody = ZIMKitMessageListPage(
-      conversationID: widget.sessionId,
-      conversationType: ZIMConversationType.group,
-    );
-
-    if (!isActive) {
-      chatBody = Stack(
-        children: [
-          AbsorbPointer(child: chatBody),
-          const Center(
-            child: Text(
-              'Sesi√≥n finalizada.',
-              style: TextStyle(color: Colors.grey),
-            ),
-          ),
-        ],
-      );
-    }
-
-    return chatBody;
-  }
-
-  // ============================================================
-  // üîµ Mensaje visual con reglas de cobro seg√∫n rol
-  // ============================================================
-  Widget _buildBillingHint(bool isSpeaker) {
-    final icon = isSpeaker ? Icons.warning_amber_rounded : Icons.info;
-    final bgColor =
-        isSpeaker ? Colors.red.withOpacity(0.12) : Colors.green.withOpacity(0.12);
-    final borderColor = isSpeaker ? Colors.redAccent : Colors.greenAccent;
-
-    final title =
-        isSpeaker ? 'Importante para ti (hablante)' : 'Importante para ti (compa√±era)';
-
-    final text = isSpeaker
-        ? 'Si t√∫ terminas la sesi√≥n antes de tiempo, se cobra el total de minutos reservados.'
-        : 'Si t√∫ terminas la sesi√≥n antes de tiempo, se te paga al menos $kMinBillingMinutes minutos, aunque haya durado menos.';
-
-    return Container(
-      decoration: BoxDecoration(
-        color: bgColor,
-        borderRadius: BorderRadius.circular(10),
-        border: Border.all(color: borderColor.withOpacity(0.7)),
-      ),
-      padding: const EdgeInsets.fromLTRB(10, 8, 22, 8),
-      child: Row(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          Icon(icon, size: 18),
-          const SizedBox(width: 8),
-          Expanded(
-            child: Column(
-              crossAxisAlignment: CrossAxisAlignment.start,
-              children: [
-                Text(
-                  title,
-                  style: const TextStyle(fontSize: 12, fontWeight: FontWeight.w600),
-                ),
-                const SizedBox(height: 2),
-                Text(text, style: const TextStyle(fontSize: 11)),
-              ],
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-
-  // ============================================================
-  // ‚úÖ Aviso para la compa√±era: l√≠mites y cierre de conversaci√≥n
-  // ============================================================
-  Widget _buildSafetyHintForCompanion() {
-    const title = 'Antes de iniciar (para ti, compa√±era)';
-    const text =
-        'Te recomendamos establecer l√≠mites claros desde el principio (temas que no quieres tratar, tono, duraci√≥n y reglas de respeto). '
-        'Procura tambi√©n cerrar las conversaciones que inicias: si algo queda pendiente, ret√≥menlo de forma ordenada; si ya qued√≥ resuelto, finalicen la sesi√≥n con claridad. '
-        'Si en cualquier momento te sientes inc√≥moda o se te falta al respeto, tienes total libertad de pausar o finalizar la sesi√≥n de inmediato.';
-
-    return Container(
-      decoration: BoxDecoration(
-        color: const Color(0xFF4F46E5).withOpacity(0.12),
-        borderRadius: BorderRadius.circular(10),
-        border: Border.all(color: const Color(0xFF4F46E5).withOpacity(0.55)),
-      ),
-      padding: const EdgeInsets.fromLTRB(10, 8, 22, 8),
-      child: const Row(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          Icon(Icons.shield_outlined, size: 18),
-          SizedBox(width: 8),
-          Expanded(
-            child: Column(
-              crossAxisAlignment: CrossAxisAlignment.start,
-              children: [
-                Text(
-                  title,
-                  style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600),
-                ),
-                SizedBox(height: 2),
-                Text(text, style: TextStyle(fontSize: 11)),
-              ],
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-}
+
+      await _ensureZegoGroup(
+        groupId: widget.sessionId,
+        groupName: 'session-${widget.sessionId}',
+        userIds: [user.uid, otherUserId],
+      );
+
+      // 3) Inicializar Call Invitation (para invitar/recibir llamadas)
+      //    Esto usa el signaling plugin y tu AppSign.
+      if (!_callInvitationInited) {
+        if (kZegoAppSign.isEmpty) {
+          throw Exception(
+            'Falta ZEGO_APP_SIGN. Ejecuta con --dart-define=ZEGO_APP_SIGN=TU_APPSIGN',
+          );
+        }
+
+        ZegoUIKitPrebuiltCallInvitationService().init(
+          appID: kZegoAppId,
+          appSign: kZegoAppSign,
+          userID: user.uid,
+          userName: myAlias,
+          plugins: [ZegoUIKitSignalingPlugin()],
+        );
+        _callInvitationInited = true;
+      }
+
+      if (!mounted) return;
+      setState(() {
+        _zegoReady = true;
+      });
+    } catch (e) {
+      if (!mounted) return;
+      setState(() {
+        _zegoError = 'No se pudo conectar a Zego: $e';
+      });
+    } finally {
+      if (mounted) {
+        setState(() => _zegoConnecting = false);
+      }
+    }
+  }
+
+
+
+  // ============================================================
+  // üîµ FINALIZAR SESI√ìN (l√≥gica de cobros manual: bot√≥n)
+  // ============================================================
+  Future<void> _finishSession() async {
+    if (_finishing) return;
+
+    final user = FirebaseAuth.instance.currentUser;
+    if (user == null) return;
+
+    // Vibraci√≥n media al finalizar sesi√≥n
+    HapticFeedback.mediumImpact();
+
+    setState(() => _finishing = true);
+
+    try {
+      final snap = await _sessionRef.get();
+      final data = snap.data();
+      if (data == null) {
+        if (mounted) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            const SnackBar(content: Text('La sesi√≥n ya no existe.')),
+          );
+        }
+        await _loadSessionOnce();
+        return;
+      }
+
+      final status = data['status'] as String? ?? 'active';
+      if (status != 'active') {
+        if (mounted) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            const SnackBar(content: Text('La sesi√≥n ya estaba finalizada.')),
+          );
+        }
+        await _loadSessionOnce();
+        return;
+      }
+
+      final speakerId = data['speakerId'] as String? ?? '';
+      final endedBy = user.uid == speakerId ? 'speaker' : 'companion';
+
+      // Duraci√≥n total contratada (ej. 30 min)
+      final durationTotal = data['durationMinutes'] as int? ?? 30;
+
+      // Calcular minutos reales usados (desde createdAt hasta ahora)
+      int realMinutes = 0;
+      final createdAtTs = data['createdAt'] as Timestamp?;
+      if (createdAtTs != null) {
+        final createdAt = createdAtTs.toDate();
+        final now = DateTime.now();
+        final diffMinutes = now.difference(createdAt).inMinutes;
+        if (diffMinutes >= 0) {
+          realMinutes = diffMinutes;
+        }
+      }
+
+      // üîí Candado: nunca m√°s de lo reservado
+      if (realMinutes > durationTotal) {
+        realMinutes = durationTotal;
+      }
+
+      // Calcular minutos a cobrar seg√∫n qui√©n termin√≥
+      int billingMinutes;
+      bool minChargeApplied = false;
+
+      if (endedBy == 'speaker') {
+        // Si el hablante corta, paga TODO (duraci√≥n contratada)
+        billingMinutes = durationTotal;
+      } else {
+        // Si la compa√±era corta, m√≠nimo 10 min
+        if (realMinutes < kMinBillingMinutes) {
+          billingMinutes = kMinBillingMinutes;
+          minChargeApplied = true;
+        } else {
+          billingMinutes = realMinutes;
+        }
+      }
+
+      final updateData = <String, dynamic>{
+        'status': 'completed',
+        'endedBy': endedBy,
+        'completedAt': FieldValue.serverTimestamp(),
+        'updatedAt': FieldValue.serverTimestamp(),
+        'realDurationMinutes': realMinutes,
+        'billingMinutes': billingMinutes,
+        'billingMinLimit': kMinBillingMinutes,
+        'minChargeApplied': minChargeApplied,
+      };
+
+      await _sessionRef.update(updateData);
+
+      try {
+        await PaymentsApi().captureSessionPayment(sessionId: widget.sessionId);
+        _captureOk = true;
+      } catch (e) {
+        _captureOk = false;
+        debugPrint('Stripe capture fallo: $e');
+      }
+
+
+      // Mezclamos los datos antiguos con los nuevos para actualizar la UI
+      final mergedData = {...data, ...updateData};
+
+      if (mounted) {
+        // Actualizamos _sessionData para que la UI refleje el cambio
+        setState(() {
+          _sessionData = mergedData;
+        });
+
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(
+            content: Text(
+              _captureOk
+                  ? 'Sesi√≥n finalizada ‚úÖ (cobro capturado)'
+                  : 'Sesi√≥n finalizada ‚úÖ (cobro pendiente ‚ö†Ô∏è)',
+            ),
+          ),
+        );
+
+      }
+    } catch (e) {
+      if (mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(content: Text('No se pudo finalizar la sesi√≥n: $e')),
+        );
+      }
+    }
+ finally {
+      if (mounted) setState(() => _finishing = false);
+    }
+  }
+
+  // ============================================================
+  // üîµ AUTO-TIMEOUT (se llama solo desde el reloj cuando se cumple el tiempo)
+  // ============================================================
+  Future<void> _autoTimeoutSession() async {
+    if (_autoTimeoutTriggered) return; // seguridad extra
+    _autoTimeoutTriggered = true;
+
+    try {
+      final snap = await _sessionRef.get();
+      final data = snap.data();
+      if (data == null) return;
+
+      final status = data['status'] as String? ?? 'active';
+      if (status != 'active') return;
+
+      final durationTotal = data['durationMinutes'] as int? ?? 30;
+
+      // En timeout consideramos que se cumpli√≥ la duraci√≥n contratada
+      final realMinutes = durationTotal;
+      final billingMinutes = durationTotal;
+
+      final updateData = <String, dynamic>{
+        'status': 'completed',
+        'endedBy': 'timeout',
+        'completedAt': FieldValue.serverTimestamp(),
+        'updatedAt': FieldValue.serverTimestamp(),
+        'realDurationMinutes': realMinutes,
+        'billingMinutes': billingMinutes,
+        'billingMinLimit': kMinBillingMinutes,
+        'minChargeApplied': false,
+      };
+
+      await _sessionRef.update(updateData);
+
+      if (mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          const SnackBar(content: Text('La sesi√≥n termin√≥ autom√°ticamente.')),
+        );
+      }
+    } catch (_) {
+      // Si falla, simplemente no hacemos nada m√°s.
+    }
+  }
+
+  // ============================================================
+  // üîµ CONFIRMAR FINALIZAR SESI√ìN
+  // ============================================================
+  Future<void> _confirmFinishSession() async {
+    if (_finishing) return;
+
+    final shouldEnd =
+        await showDialog<bool>(
+          context: context,
+          builder: (context) {
+            return AlertDialog(
+              title: const Text('Finalizar sesi√≥n'),
+              content: const Text(
+                '¬øSeguro que quieres finalizar la sesi√≥n? '
+                'Esta acci√≥n no se puede deshacer.',
+              ),
+              actions: [
+                TextButton(
+                  onPressed: () => Navigator.of(context).pop(false),
+                  child: const Text('Cancelar'),
+                ),
+                ElevatedButton(
+                  onPressed: () => Navigator.of(context).pop(true),
+                  child: const Text('S√≠, finalizar'),
+                ),
+              ],
+            );
+          },
+        ) ??
+        false;
+
+    if (!shouldEnd) return;
+
+    await _finishSession();
+  }
+
+  // ============================================================
+  // üîµ UI COMPLETA DE LA SESI√ìN
+  // ============================================================
+  @override
+  Widget build(BuildContext context) {
+    final user = FirebaseAuth.instance.currentUser;
+    if (user == null) {
+      return const Scaffold(body: Center(child: Text('Debes iniciar sesi√≥n.')));
+    }
+
+    // ‚è≥ Carga inicial de la sesi√≥n
+    if (_sessionLoading) {
+      return Scaffold(
+        appBar: AppBar(title: const Text('Sesi√≥n')),
+        body: const Center(child: CircularProgressIndicator()),
+      );
+    }
+
+    if (_sessionError != null || _sessionData == null) {
+      return Scaffold(
+        appBar: AppBar(title: const Text('Sesi√≥n')),
+        body: Center(
+          child: Text(
+            _sessionError ?? 'La sesi√≥n no existe o fue eliminada.',
+            textAlign: TextAlign.center,
+          ),
+        ),
+      );
+    }
+
+    final data = _sessionData!;
+    final status = data['status'] as String? ?? 'active';
+    final endedBy = data['endedBy'] as String?;
+    final isActive = status == 'active';
+
+    final speakerAlias = data['speakerAlias'] ?? 'Hablante';
+    final companionAlias = data['companionAlias'] ?? 'Compa√±era';
+
+    final price = (data['priceCents'] ?? 0) / 100.0;
+    final duration = data['durationMinutes'] as int? ?? 30;
+    final currency = (data['currency'] ?? 'usd').toUpperCase();
+
+    final realDuration = data['realDurationMinutes'] as int?;
+    final billingMinutes = data['billingMinutes'] as int?;
+    final minChargeApplied = data['minChargeApplied'] as bool? ?? false;
+    final billingMinLimit =
+        data['billingMinLimit'] as int? ?? kMinBillingMinutes;
+
+    final isSpeakerInSession = data['speakerId'] == user.uid;
+    final otherAlias = isSpeakerInSession ? companionAlias : speakerAlias;
+    final otherUserId = _resolveOtherUserId(data, user.uid);
+
+    // createdAt para el reloj
+    final createdAtTs = data['createdAt'] as Timestamp?;
+    final createdAt = createdAtTs?.toDate();
+
+    // Label de estado amigable
+    String statusLabel;
+    if (status == 'active') {
+      statusLabel = 'Activa';
+    } else if (status == 'completed') {
+      if (endedBy == 'speaker') {
+        statusLabel = 'Finalizada por hablante';
+      } else if (endedBy == 'companion') {
+        statusLabel = 'Finalizada por compa√±era';
+      } else if (endedBy == 'timeout') {
+        statusLabel = 'Finalizada por tiempo';
+      } else {
+        statusLabel = 'Finalizada';
+      }
+    } else {
+      statusLabel = status;
+    }
+
+    // Texto de duraci√≥n compacto (cuando ya termin√≥)
+    String durationText;
+    if (!isActive && realDuration != null && billingMinutes != null) {
+      if (minChargeApplied) {
+        durationText =
+            'Res: $duration min ‚Ä¢ Real: $realDuration ‚Ä¢ Cobro: $billingMinutes (min $billingMinLimit)';
+      } else {
+        durationText =
+            'Res: $duration min ‚Ä¢ Real: $realDuration ‚Ä¢ Cobro: $billingMinutes';
+      }
+    } else if (realDuration != null && !isActive) {
+      durationText = 'Res: $duration min ‚Ä¢ Real: $realDuration';
+    } else {
+      durationText = 'Reservada: $duration min';
+    }
+
+    // ‚õî BLOQUEAR BACK mientras la sesi√≥n est√° activa
+    return WillPopScope(
+      onWillPop: () async {
+        if (isActive) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            const SnackBar(
+              content: Text(
+                'No puedes salir de una sesi√≥n activa. '
+                'Primero debes finalizarla.',
+              ),
+            ),
+          );
+          return false;
+        }
+        return true;
+      },
+      child: Scaffold(
+        resizeToAvoidBottomInset: true,
+        appBar: AppBar(
+          title: Text(isActive ? otherAlias : 'Sesi√≥n finalizada'),
+          centerTitle: true,
+          actions: [
+            // ‚úÖ Llamada de voz (invita al otro)
+            if (isActive)
+              ZegoSendCallInvitationButton(
+                isVideoCall: false,
+                resourceID: kZegoCallInvitationResourceId,
+                invitees: [ZegoUIKitUser(id: otherUserId, name: otherAlias)],
+              ),
+
+            // ‚úÖ Videollamada (invita al otro)
+            if (isActive)
+              ZegoSendCallInvitationButton(
+                isVideoCall: true,
+                resourceID: kZegoCallInvitationResourceId,
+                invitees: [ZegoUIKitUser(id: otherUserId, name: otherAlias)],
+              ),
+            // Bot√≥n peque√±o para finalizar sesi√≥n (solo si est√° activa)
+            if (isActive)
+              IconButton(
+                icon: _finishing
+                    ? const SizedBox(
+                        height: 16,
+                        width: 16,
+                        child: CircularProgressIndicator(strokeWidth: 2),
+                      )
+                    : const Icon(Icons.call_end),
+                tooltip: 'Finalizar sesi√≥n',
+                onPressed: _finishing ? null : _confirmFinishSession,
+              ),
+          ],
+        ),
+        body: Column(
+          children: [
+            // ======================================================
+            // üî∏ HEADER PEQUE√ëO DE SESI√ìN
+            // ======================================================
+            Padding(
+              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
+              child: Row(
+                children: [
+                  CircleAvatar(
+                    radius: 18,
+                    child: Text(
+                      otherAlias.isNotEmpty ? otherAlias[0].toUpperCase() : '?',
+                    ),
+                  ),
+                  const SizedBox(width: 10),
+                  Expanded(
+                    child: Column(
+                      crossAxisAlignment: CrossAxisAlignment.start,
+                      children: [
+                        Text(
+                          'H: $speakerAlias ‚Ä¢ C: $companionAlias',
+                          style: const TextStyle(
+                            fontSize: 12,
+                            color: Colors.grey,
+                          ),
+                          overflow: TextOverflow.ellipsis,
+                        ),
+                        const SizedBox(height: 2),
+                        Text(
+                          durationText,
+                          style: const TextStyle(
+                            fontSize: 11,
+                            color: Colors.grey,
+                          ),
+                        ),
+                      ],
+                    ),
+                  ),
+                  const SizedBox(width: 8),
+                  Column(
+                    crossAxisAlignment: CrossAxisAlignment.end,
+                    children: [
+                      // ‚è±Ô∏è Reloj visual + auto-timeout
+                      if (isActive && createdAt != null)
+                        StreamBuilder<int>(
+                          stream: Stream.periodic(const Duration(seconds: 1), (
+                            _,
+                          ) {
+                            final diff = DateTime.now()
+                                .difference(createdAt)
+                                .inSeconds;
+                            return diff < 0 ? 0 : diff;
+                          }),
+                          builder: (context, snapshot) {
+                            final totalSeconds = snapshot.data ?? 0;
+                            final hours = totalSeconds ~/ 3600;
+                            final minutes = (totalSeconds % 3600) ~/ 60;
+                            final seconds = totalSeconds % 60;
+
+                            String formatted;
+                            if (hours > 0) {
+                              formatted =
+                                  '${hours.toString().padLeft(2, '0')}'
+                                  ':${minutes.toString().padLeft(2, '0')}'
+                                  ':${seconds.toString().padLeft(2, '0')}';
+                            } else {
+                              formatted =
+                                  '${minutes.toString().padLeft(2, '0')}'
+                                  ':${seconds.toString().padLeft(2, '0')}';
+                            }
+
+                            // üî• Auto-timeout: cuando se cumple la duraci√≥n
+                            final sessionTotalSeconds = duration * 60;
+                            if (isActive &&
+                                !_autoTimeoutTriggered &&
+                                sessionTotalSeconds > 0 &&
+                                totalSeconds >= sessionTotalSeconds) {
+                              _autoTimeoutSession();
+                            }
+
+                            return Text(
+                              'Tiempo: $formatted',
+                              style: const TextStyle(
+                                fontSize: 11,
+                                color: Colors.grey,
+                              ),
+                            );
+                          },
+                        ),
+                      const SizedBox(height: 2),
+                      Text(
+                        '\$${price.toStringAsFixed(2)} $currency',
+                        style: const TextStyle(
+                          fontSize: 12,
+                          fontWeight: FontWeight.w600,
+                        ),
+                      ),
+                      const SizedBox(height: 2),
+                      Text(
+                        statusLabel,
+                        style: TextStyle(
+                          fontSize: 11,
+                          color: isActive ? Colors.greenAccent : Colors.redAccent,
+                        ),
+                      ),
+                    ],
+                  ),
+                ],
+              ),
+            ),
+
+            // ======================================================
+            // üî∏ BARRA DE PROGRESO DE LA SESI√ìN (‚úÖ FIX COLOR / TRACK)
+            // ======================================================
+            if (isActive && createdAt != null)
+              Padding(
+                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
+                child: StreamBuilder<int>(
+                  stream: Stream.periodic(const Duration(seconds: 1), (_) {
+                    final diff = DateTime.now().difference(createdAt).inSeconds;
+                    return diff < 0 ? 0 : diff;
+                  }),
+                  builder: (context, snapshot) {
+                    final totalSeconds = snapshot.data ?? 0;
+                    final totalSessionSeconds = duration * 60;
+
+                    double progress = 0;
+                    if (totalSessionSeconds > 0) {
+                      progress = totalSeconds / totalSessionSeconds;
+                      if (progress.isNaN || progress.isInfinite) progress = 0;
+                      if (progress < 0) progress = 0;
+                      if (progress > 1) progress = 1;
+                    }
+
+                    final percent =
+                        (progress * 100).clamp(0, 100).toStringAsFixed(0);
+
+                    return Column(
+                      crossAxisAlignment: CrossAxisAlignment.stretch,
+                      children: [
+                        ClipRRect(
+                          borderRadius: BorderRadius.circular(8),
+                          child: LinearProgressIndicator(
+                            value: progress,
+                            minHeight: 6,
+                            // ‚úÖ en lugar del verde del theme
+                            color: const Color(0xFF4F46E5),
+                            // ‚úÖ track neutro (evita que se vea ‚Äúrelleno‚Äù desde inicio)
+                            backgroundColor: Colors.white12,
+                          ),
+                        ),
+                        const SizedBox(height: 4),
+                        Text(
+                          'Progreso de la sesi√≥n: $percent%',
+                          textAlign: TextAlign.right,
+                          style: const TextStyle(fontSize: 11, color: Colors.grey),
+                        ),
+                      ],
+                    );
+                  },
+                ),
+              ),
+
+            // ======================================================
+            // üî∏ AVISO L√çMITES (‚úÖ SOLO COMPA√ëERA, CERRABLE)
+            // ======================================================
+            if (isActive && !isSpeakerInSession && _showSafetyHint)
+              Padding(
+                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
+                child: Stack(
+                  children: [
+                    _buildSafetyHintForCompanion(),
+                    Positioned(
+                      right: 4,
+                      top: 4,
+                      child: InkWell(
+                        onTap: () => setState(() => _showSafetyHint = false),
+                        child: const Icon(Icons.close, size: 16),
+                      ),
+                    ),
+                  ],
+                ),
+              ),
+
+            // ======================================================
+            // üî∏ AVISO DE REGLA DE COBRO (con bot√≥n de cerrar)
+            // ======================================================
+            if (isActive && _showBillingHint)
+              Padding(
+                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
+                child: Stack(
+                  children: [
+                    _buildBillingHint(isSpeakerInSession),
+                    Positioned(
+                      right: 4,
+                      top: 4,
+                      child: InkWell(
+                        onTap: () {
+                          setState(() {
+                            _showBillingHint = false;
+                          });
+                        },
+                        child: const Icon(Icons.close, size: 16),
+                      ),
+                    ),
+                  ],
+                ),
+              ),
+
+            Expanded(child: _buildZegoChat(isActive: isActive)),
+          ],
+        ),
+      ),
+    );
+  }
+
+  Widget _buildZegoChat({required bool isActive}) {
+    if (_zegoError != null) {
+      return Center(
+        child: Text(
+          _zegoError!,
+          textAlign: TextAlign.center,
+          style: const TextStyle(color: Colors.redAccent),
+        ),
+      );
+    }
+
+    if (!_zegoReady) {
+      return const Center(child: CircularProgressIndicator());
+    }
+
+    Widget chatBody = ZIMKitMessageListPage(
+      conversationID: widget.sessionId,
+      conversationType: ZIMConversationType.group,
+    );
+
+    if (!isActive) {
+      chatBody = Stack(
+        children: [
+          AbsorbPointer(child: chatBody),
+          const Center(
+            child: Text(
+              'Sesi√≥n finalizada.',
+              style: TextStyle(color: Colors.grey),
+            ),
+          ),
+        ],
+      );
+    }
+
+    return chatBody;
+  }
+
+  // ============================================================
+  // üîµ Mensaje visual con reglas de cobro seg√∫n rol
+  // ============================================================
+  Widget _buildBillingHint(bool isSpeaker) {
+    final icon = isSpeaker ? Icons.warning_amber_rounded : Icons.info;
+    final bgColor =
+        isSpeaker ? Colors.red.withOpacity(0.12) : Colors.green.withOpacity(0.12);
+    final borderColor = isSpeaker ? Colors.redAccent : Colors.greenAccent;
+
+    final title =
+        isSpeaker ? 'Importante para ti (hablante)' : 'Importante para ti (compa√±era)';
+
+    final text = isSpeaker
+        ? 'Si t√∫ terminas la sesi√≥n antes de tiempo, se cobra el total de minutos reservados.'
+        : 'Si t√∫ terminas la sesi√≥n antes de tiempo, se te paga al menos $kMinBillingMinutes minutos, aunque haya durado menos.';
+
+    return Container(
+      decoration: BoxDecoration(
+        color: bgColor,
+        borderRadius: BorderRadius.circular(10),
+        border: Border.all(color: borderColor.withOpacity(0.7)),
+      ),
+      padding: const EdgeInsets.fromLTRB(10, 8, 22, 8),
+      child: Row(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          Icon(icon, size: 18),
+          const SizedBox(width: 8),
+          Expanded(
+            child: Column(
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: [
+                Text(
+                  title,
+                  style: const TextStyle(fontSize: 12, fontWeight: FontWeight.w600),
+                ),
+                const SizedBox(height: 2),
+                Text(text, style: const TextStyle(fontSize: 11)),
+              ],
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+
+  // ============================================================
+  // ‚úÖ Aviso para la compa√±era: l√≠mites y cierre de conversaci√≥n
+  // ============================================================
+  Widget _buildSafetyHintForCompanion() {
+    const title = 'Antes de iniciar (para ti, compa√±era)';
+    const text =
+        'Te recomendamos establecer l√≠mites claros desde el principio (temas que no quieres tratar, tono, duraci√≥n y reglas de respeto). '
+        'Procura tambi√©n cerrar las conversaciones que inicias: si algo queda pendiente, ret√≥menlo de forma ordenada; si ya qued√≥ resuelto, finalicen la sesi√≥n con claridad. '
+        'Si en cualquier momento te sientes inc√≥moda o se te falta al respeto, tienes total libertad de pausar o finalizar la sesi√≥n de inmediato.';
+
+    return Container(
+      decoration: BoxDecoration(
+        color: const Color(0xFF4F46E5).withOpacity(0.12),
+        borderRadius: BorderRadius.circular(10),
+        border: Border.all(color: const Color(0xFF4F46E5).withOpacity(0.55)),
+      ),
+      padding: const EdgeInsets.fromLTRB(10, 8, 22, 8),
+      child: const Row(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          Icon(Icons.shield_outlined, size: 18),
+          SizedBox(width: 8),
+          Expanded(
+            child: Column(
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: [
+                Text(
+                  title,
+                  style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600),
+                ),
+                SizedBox(height: 2),
+                Text(text, style: TextStyle(fontSize: 11)),
+              ],
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+}
diff -ruN lissen_zip/lib/features/zego/zego_config.dart lissen_fix/lib/features/zego/zego_config.dart
--- lissen_zip/lib/features/zego/zego_config.dart	2025-12-28 17:44:56.000000000 +0000
+++ lissen_fix/lib/features/zego/zego_config.dart	2025-12-29 03:57:51.589939201 +0000
@@ -1,3 +1,24 @@
-const int kZegoAppId = 346791689;
-const int kZegoTokenExpireSeconds = 60 * 60 * 2;
-const String kZegoTokenFunctionName = 'zego_generateToken';
+// ZEGOCLOUD config
+//
+// ‚úÖ Para que el chat y las llamadas funcionen de forma confiable (sin quedarse cargando),
+// inicializa Zego con AppSign.
+//
+// P√°salo con --dart-define:
+// flutter run --dart-define=ZEGO_APP_SIGN=TU_APPSIGN
+//
+// (En producci√≥n se recomienda token server-side, pero primero lo dejamos funcionando.)
+
+const int kZegoAppId = 346791689;
+
+// AppSign desde la consola de ZEGOCLOUD.
+// Si lo dejas vac√≠o, Zego no podr√° conectarte (chat/llamadas se quedan cargando).
+const String kZegoAppSign = String.fromEnvironment('ZEGO_APP_SIGN', defaultValue: '');
+
+// Si usas Cloud Function para tokens (opcional por ahora)
+const int kZegoTokenExpireSeconds = 60 * 60 * 2;
+const String kZegoTokenFunctionName = 'zego_generateToken';
+
+// Para Call Invitation (notificaciones de llamada). En foreground suele funcionar sin esto,
+// pero para background/quit normalmente s√≠ lo pide. Config√∫ralo en Zego Console.
+const String kZegoCallInvitationResourceId =
+    String.fromEnvironment('ZEGO_CALL_RESOURCE_ID', defaultValue: 'lissen_call');
diff -ruN lissen_zip/lib/main.dart lissen_fix/lib/main.dart
--- lissen_zip/lib/main.dart	2025-12-28 19:54:22.000000000 +0000
+++ lissen_fix/lib/main.dart	2025-12-29 03:52:19.398770966 +0000
@@ -1,186 +1,193 @@
-import 'package:flutter/material.dart';
-import 'package:firebase_core/firebase_core.dart';
-import 'package:firebase_auth/firebase_auth.dart';
-import 'package:cloud_firestore/cloud_firestore.dart';
-import 'package:zego_zimkit/zego_zimkit.dart';
-
-import 'firebase_options.dart';
-import 'screens/auth_screen.dart';
-import 'screens/onboarding_screen.dart';
-import 'screens/lissen_home.dart';
-import 'features/sessions/ui/session_screen.dart';
-import 'screens/global_session_rating_listener.dart';
-import 'features/zego/zego_config.dart';
-
-import 'theme/chat_theme.dart';
-
-Future<void> main() async {
-  WidgetsFlutterBinding.ensureInitialized();
-  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
-  await ZIMKit().init(appID: kZegoAppId);
-  runApp(const LissenApp());
-}
-
-class LissenApp extends StatelessWidget {
-  const LissenApp({super.key});
-
-  @override
-  Widget build(BuildContext context) {
-    const bgGradient = LinearGradient(
-      begin: Alignment.topLeft,
-      end: Alignment.bottomRight,
-      colors: [
-        Color(0xFF020617), // slate-950
-        Color(0xFF0B1B4D), // deep blue
-        Color(0xFF0F172A), // slate-900
-      ],
-    );
-
-    return MaterialApp(
-      debugShowCheckedModeBanner: false,
-
-      // ‚úÖ Tema (tuya)
-      theme: ChatTheme.dark(),
-      darkTheme: ChatTheme.dark(),
-      themeMode: ThemeMode.system,
-
-      // ‚úÖ Fondo global
-      builder: (context, child) {
-        return Container(
-          decoration: const BoxDecoration(gradient: bgGradient),
-          child: child ?? const SizedBox.shrink(),
-        );
-      },
-
-      home: const _AuthGate(),
-    );
-  }
-}
-
-/// Escucha el estado de Firebase Auth.
-/// Si no hay usuario -> AuthScreen
-/// Si hay usuario -> _RootController envuelto con GlobalSessionRatingListener
-class _AuthGate extends StatelessWidget {
-  const _AuthGate({super.key});
-
-  @override
-  Widget build(BuildContext context) {
-    return StreamBuilder<User?>(
-      stream: FirebaseAuth.instance.authStateChanges(),
-      builder: (context, snap) {
-        if (snap.connectionState == ConnectionState.waiting) {
-          return const Scaffold(
-            body: Center(child: CircularProgressIndicator()),
-          );
-        }
-
-        final user = snap.data;
-
-        // üî¥ Sin usuario: mostrar tu pantalla real de login/registro
-        if (user == null) {
-          return const AuthScreen();
-        }
-
-        // üü¢ Con usuario: montamos el listener global alrededor del root
-        return GlobalSessionRatingListener(
-          child: _RootController(userId: user.uid),
-        );
-      },
-    );
-  }
-}
-
-/// Mira el documento en 'users/{uid}' y decide:
-/// - si falta onboarding -> OnboardingScreen
-/// - si ya est√° listo   ->
-///     - si hay sesi√≥n activa -> SessionConversationScreen (LOCK-IN)
-///     - si no hay sesi√≥n     -> LissenHome
-class _RootController extends StatelessWidget {
-  final String userId;
-
-  const _RootController({super.key, required this.userId});
-
-  @override
-  Widget build(BuildContext context) {
-    final docRef = FirebaseFirestore.instance.collection('users').doc(userId);
-
-    return FutureBuilder<DocumentSnapshot<Map<String, dynamic>>>(
-      future: docRef.get(),
-      builder: (context, snap) {
-        if (snap.connectionState == ConnectionState.waiting) {
-          return const Scaffold(
-            body: Center(child: CircularProgressIndicator()),
-          );
-        }
-
-        if (snap.hasError) {
-          return Scaffold(
-            body: Center(
-              child: Text(
-                'Error cargando usuario:\n${snap.error}',
-                textAlign: TextAlign.center,
-              ),
-            ),
-          );
-        }
-
-        // üëá Si no existe el documento en 'users/{userId}',
-        // lo creamos vac√≠o y mandamos a Onboarding.
-        if (!snap.hasData || !snap.data!.exists) {
-          FirebaseFirestore.instance.collection('users').doc(userId).set({
-            'uid': userId,
-            'onboardingCompleted': false,
-          }, SetOptions(merge: true));
-
-          return OnboardingScreen(uid: userId, initialData: null);
-        }
-
-        final data = snap.data!.data() ?? {};
-        final onboardingCompleted = data['onboardingCompleted'] == true;
-
-        if (!onboardingCompleted) {
-          return OnboardingScreen(
-            uid: userId,
-            initialData: data.isEmpty ? null : data,
-          );
-        }
-
-        // üî• LOCK-IN solo depende de sessions, aqu√≠ s√≠ usamos StreamBuilder
-        return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
-          stream: FirebaseFirestore.instance
-              .collection('sessions')
-              .where('participants', arrayContains: userId)
-              .where('status', isEqualTo: 'active')
-              .snapshots(),
-          builder: (context, sesSnap) {
-            if (sesSnap.connectionState == ConnectionState.waiting) {
-              return const Scaffold(
-                body: Center(child: CircularProgressIndicator()),
-              );
-            }
-
-            if (sesSnap.hasError) {
-              return Scaffold(
-                body: Center(
-                  child: Text(
-                    'Error cargando sesiones:\n${sesSnap.error}',
-                    textAlign: TextAlign.center,
-                  ),
-                ),
-              );
-            }
-
-            final docs = sesSnap.data?.docs ?? [];
-
-            if (docs.isNotEmpty) {
-              final sessionId = docs.first.id;
-              return SessionConversationScreen(sessionId: sessionId);
-            }
-
-            return const LissenHome();
-          },
-        );
-      },
-    );
-  }
-}
+import 'package:flutter/material.dart';
+import 'package:firebase_core/firebase_core.dart';
+import 'package:firebase_auth/firebase_auth.dart';
+import 'package:cloud_firestore/cloud_firestore.dart';
+import 'package:zego_zimkit/zego_zimkit.dart';
+import 'package:flutter/foundation.dart';
+
+import 'firebase_options.dart';
+import 'screens/auth_screen.dart';
+import 'screens/onboarding_screen.dart';
+import 'screens/lissen_home.dart';
+import 'features/sessions/ui/session_screen.dart';
+import 'screens/global_session_rating_listener.dart';
+import 'features/zego/zego_config.dart';
+
+import 'theme/chat_theme.dart';
+
+Future<void> main() async {
+  WidgetsFlutterBinding.ensureInitialized();
+  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
+  // ‚úÖ No dejamos que un problema de Zego rompa la pantalla de login.
+  // Si AppSign no est√° configurado, al menos la app debe arrancar.
+  try {
+    await ZIMKit().init(appID: kZegoAppId, appSign: kZegoAppSign);
+  } catch (e, st) {
+    debugPrint('‚ö†Ô∏è Zego init fall√≥ (la app seguir√° corriendo): $e\n$st');
+  }
+  runApp(const LissenApp());
+}
+
+class LissenApp extends StatelessWidget {
+  const LissenApp({super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    const bgGradient = LinearGradient(
+      begin: Alignment.topLeft,
+      end: Alignment.bottomRight,
+      colors: [
+        Color(0xFF020617), // slate-950
+        Color(0xFF0B1B4D), // deep blue
+        Color(0xFF0F172A), // slate-900
+      ],
+    );
+
+    return MaterialApp(
+      debugShowCheckedModeBanner: false,
+
+      // ‚úÖ Tema (tuya)
+      theme: ChatTheme.dark(),
+      darkTheme: ChatTheme.dark(),
+      themeMode: ThemeMode.system,
+
+      // ‚úÖ Fondo global
+      builder: (context, child) {
+        return Container(
+          decoration: const BoxDecoration(gradient: bgGradient),
+          child: child ?? const SizedBox.shrink(),
+        );
+      },
+
+      home: const _AuthGate(),
+    );
+  }
+}
+
+/// Escucha el estado de Firebase Auth.
+/// Si no hay usuario -> AuthScreen
+/// Si hay usuario -> _RootController envuelto con GlobalSessionRatingListener
+class _AuthGate extends StatelessWidget {
+  const _AuthGate({super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    return StreamBuilder<User?>(
+      stream: FirebaseAuth.instance.authStateChanges(),
+      builder: (context, snap) {
+        if (snap.connectionState == ConnectionState.waiting) {
+          return const Scaffold(
+            body: Center(child: CircularProgressIndicator()),
+          );
+        }
+
+        final user = snap.data;
+
+        // üî¥ Sin usuario: mostrar tu pantalla real de login/registro
+        if (user == null) {
+          return const AuthScreen();
+        }
+
+        // üü¢ Con usuario: montamos el listener global alrededor del root
+        return GlobalSessionRatingListener(
+          child: _RootController(userId: user.uid),
+        );
+      },
+    );
+  }
+}
+
+/// Mira el documento en 'users/{uid}' y decide:
+/// - si falta onboarding -> OnboardingScreen
+/// - si ya est√° listo   ->
+///     - si hay sesi√≥n activa -> SessionConversationScreen (LOCK-IN)
+///     - si no hay sesi√≥n     -> LissenHome
+class _RootController extends StatelessWidget {
+  final String userId;
+
+  const _RootController({super.key, required this.userId});
+
+  @override
+  Widget build(BuildContext context) {
+    final docRef = FirebaseFirestore.instance.collection('users').doc(userId);
+
+    return FutureBuilder<DocumentSnapshot<Map<String, dynamic>>>(
+      future: docRef.get(),
+      builder: (context, snap) {
+        if (snap.connectionState == ConnectionState.waiting) {
+          return const Scaffold(
+            body: Center(child: CircularProgressIndicator()),
+          );
+        }
+
+        if (snap.hasError) {
+          return Scaffold(
+            body: Center(
+              child: Text(
+                'Error cargando usuario:\n${snap.error}',
+                textAlign: TextAlign.center,
+              ),
+            ),
+          );
+        }
+
+        // üëá Si no existe el documento en 'users/{userId}',
+        // lo creamos vac√≠o y mandamos a Onboarding.
+        if (!snap.hasData || !snap.data!.exists) {
+          FirebaseFirestore.instance.collection('users').doc(userId).set({
+            'uid': userId,
+            'onboardingCompleted': false,
+          }, SetOptions(merge: true));
+
+          return OnboardingScreen(uid: userId, initialData: null);
+        }
+
+        final data = snap.data!.data() ?? {};
+        final onboardingCompleted = data['onboardingCompleted'] == true;
+
+        if (!onboardingCompleted) {
+          return OnboardingScreen(
+            uid: userId,
+            initialData: data.isEmpty ? null : data,
+          );
+        }
+
+        // üî• LOCK-IN solo depende de sessions, aqu√≠ s√≠ usamos StreamBuilder
+        return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
+          stream: FirebaseFirestore.instance
+              .collection('sessions')
+              .where('participants', arrayContains: userId)
+              .where('status', isEqualTo: 'active')
+              .snapshots(),
+          builder: (context, sesSnap) {
+            if (sesSnap.connectionState == ConnectionState.waiting) {
+              return const Scaffold(
+                body: Center(child: CircularProgressIndicator()),
+              );
+            }
+
+            if (sesSnap.hasError) {
+              return Scaffold(
+                body: Center(
+                  child: Text(
+                    'Error cargando sesiones:\n${sesSnap.error}',
+                    textAlign: TextAlign.center,
+                  ),
+                ),
+              );
+            }
+
+            final docs = sesSnap.data?.docs ?? [];
+
+            if (docs.isNotEmpty) {
+              final sessionId = docs.first.id;
+              return SessionConversationScreen(sessionId: sessionId);
+            }
+
+            return const LissenHome();
+          },
+        );
+      },
+    );
+  }
+}
diff -ruN lissen_zip/pubspec.yaml lissen_fix/pubspec.yaml
--- lissen_zip/pubspec.yaml	2025-12-28 19:25:04.000000000 +0000
+++ lissen_fix/pubspec.yaml	2025-12-29 03:57:04.586716584 +0000
@@ -1,62 +1,64 @@
-name: lissen_mvp
-description: "A new Flutter project."
-publish_to: 'none'
-
-version: 1.0.0+1
-
-environment:
-  sdk: '>=3.10.1 <4.0.0'
-
-dependencies:
-  flutter:
-    sdk: flutter
-  url_launcher: ^6.2.6
-
-  cupertino_icons: ^1.0.8
-  video_player: ^2.8.2
-
-  # --------------------------
-  # Firebase (compatibles entre s√≠)
-  # --------------------------
-  firebase_core: ^3.6.0
-  firebase_auth: ^5.1.4
-  cloud_firestore: ^5.4.3
-  cloud_functions: ^5.1.3
-  flutter_stripe: ^11.1.0
-  firebase_storage: ^12.4.10
-  cached_network_image: ^3.3.1
+name: lissen_mvp
+description: "A new Flutter project."
+publish_to: 'none'
+
+version: 1.0.0+1
+
+environment:
+  sdk: '>=3.10.1 <4.0.0'
+
+dependencies:
+  flutter:
+    sdk: flutter
+  url_launcher: ^6.2.6
+
+  cupertino_icons: ^1.0.8
+  video_player: ^2.8.2
+
+  # --------------------------
+  # Firebase (compatibles entre s√≠)
+  # --------------------------
+  firebase_core: ^3.6.0
+  firebase_auth: ^5.1.4
+  cloud_firestore: ^5.4.3
+  cloud_functions: ^5.1.3
+  flutter_stripe: ^11.1.0
+  firebase_storage: ^12.4.10
+  cached_network_image: ^3.3.1
   zego_zimkit: ^1.19.3
   zego_uikit_prebuilt_call: ^4.22.2
+  zego_uikit_signaling_plugin: ^2.8.20
   zego_zim: ^2.25.0+1
-
-dependency_overrides:
-  zego_express_engine: 3.22.0
 
+
+  # --------------------------
+  # Plugins adicionales
   # --------------------------
-  # Plugins adicionales
-  # --------------------------
-  image_picker: ^1.2.1
-  geolocator: ^12.0.0
-  just_audio: ^0.9.36
-  geocoding: ^3.0.0
-  google_maps_flutter: ^2.7.0
-
-  # --------------------------
-  # üîµ Login Social
-  # --------------------------
-  google_sign_in: ^6.2.1
-  flutter_facebook_auth: ^6.1.1
-
-  # üîµ Botones oficiales (UI)
-  sign_in_button: ^4.0.1   # üëà SOLO CAMBI√â ESTA VERSI√ìN
-
-dev_dependencies:
-  flutter_test:
-    sdk: flutter
-  flutter_lints: ^4.0.0
-
-flutter:
-  uses-material-design: true
-
-  assets:
-    - assets/sounds/offer_request.wav
+  image_picker: ^1.2.1
+  geolocator: ^12.0.0
+  just_audio: ^0.9.36
+  geocoding: ^3.0.0
+  google_maps_flutter: ^2.7.0
+
+  # --------------------------
+  # üîµ Login Social
+  # --------------------------
+  google_sign_in: ^6.2.1
+  flutter_facebook_auth: ^6.1.1
+
+  # üîµ Botones oficiales (UI)
+  sign_in_button: ^4.0.1   # üëà SOLO CAMBI√â ESTA VERSI√ìN
+
+dev_dependencies:
+  flutter_test:
+    sdk: flutter
+  flutter_lints: ^4.0.0
+
+flutter:
+  uses-material-design: true
+
+  assets:
+    - assets/sounds/offer_request.wav
+
+dependency_overrides:
+  zego_express_engine: 3.22.0
